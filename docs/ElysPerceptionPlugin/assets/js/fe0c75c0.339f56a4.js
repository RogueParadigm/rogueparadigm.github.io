"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[622],{5086(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"Internal-PluginState","title":"Internal Plugin State","description":"Note: This is an internal technical state document for plugin developers and maintainers. For user-facing documentation, see the Documentation README.","source":"@site/docs/Internal-PluginState.md","sourceDirName":".","slug":"/Internal-PluginState","permalink":"/docs/ElysPerceptionPlugin/docs/Internal-PluginState","draft":false,"unlisted":false,"editUrl":"https://github.com/RogueParadigm/ElysPerceptionPlugin/tree/main/website/docs/Internal-PluginState.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"Internal-PluginState","title":"Internal Plugin State","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Examples","permalink":"/docs/ElysPerceptionPlugin/docs/Examples"}}');var r=i(4848),c=i(8453);const s={id:"Internal-PluginState",title:"Internal Plugin State",sidebar_position:7},t=void 0,d={},o=[{value:"1) Current source layout",id:"1-current-source-layout",level:2},{value:"Public",id:"public",level:3},{value:"Private",id:"private",level:3},{value:"2) File-by-file responsibilities",id:"2-file-by-file-responsibilities",level:2},{value:"<code>Public/ElysPerceptionPlugin.h</code>",id:"publicelysperceptionpluginh",level:3},{value:"<code>Private/ElysPerceptionPlugin.cpp</code>",id:"privateelysperceptionplugincpp",level:3},{value:"<code>Public/Core/ERPTargetable.h</code>",id:"publiccoreerptargetableh",level:3},{value:"<code>Public/Core/ERPInteractable.h</code>",id:"publiccoreerpinteractableh",level:3},{value:"<code>Public/Core/ERPPerceptionComponent.h</code>",id:"publiccoreerpperceptioncomponenth",level:3},{value:"<code>Private/Core/ERPPerceptionComponent.cpp</code>",id:"privatecoreerpperceptioncomponentcpp",level:3},{value:"3) Architecture overview",id:"3-architecture-overview",level:2},{value:"Core concept: Pure Perception, Multi-Channel",id:"core-concept-pure-perception-multi-channel",level:3},{value:"Multi-channel state management",id:"multi-channel-state-management",level:3},{value:"4) Pipeline execution (runtime details)",id:"4-pipeline-execution-runtime-details",level:2},{value:"Channel pipeline architecture",id:"channel-pipeline-architecture",level:3},{value:"Evaluation flow per channel",id:"evaluation-flow-per-channel",level:3},{value:"Perception context",id:"perception-context",level:3},{value:"Extensibility",id:"extensibility",level:3},{value:"5) Events: rules and expectations",id:"5-events-rules-and-expectations",level:2},{value:"Generic multi-channel events",id:"generic-multi-channel-events",level:3},{value:"Event ordering",id:"event-ordering",level:3},{value:"No focus/winner semantics",id:"no-focuswinner-semantics",level:3},{value:"6) Feature set recap",id:"6-feature-set-recap",level:2},{value:"Pure perception (channel-agnostic)",id:"pure-perception-channel-agnostic",level:3},{value:"Perception context providers",id:"perception-context-providers",level:3},{value:"Pipeline extensibility",id:"pipeline-extensibility",level:3},{value:"Configuration flexibility",id:"configuration-flexibility",level:3},{value:"7) Non-goals (intentionally excluded)",id:"7-non-goals-intentionally-excluded",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," This is an internal technical state document for plugin developers and maintainers. For user-facing documentation, see the ",(0,r.jsx)(n.a,{href:"/",children:"Documentation README"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Date: 2026-01-15"}),"\n",(0,r.jsxs)(n.p,{children:["This document is a snapshot of the plugin's ",(0,r.jsx)(n.strong,{children:"current architecture, features, and file roles"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-current-source-layout",children:"1) Current source layout"}),"\n",(0,r.jsxs)(n.p,{children:["Root: ",(0,r.jsx)(n.code,{children:"Plugins/ElysPerceptionPlugin/Source/ElysPerceptionPlugin"})]}),"\n",(0,r.jsx)(n.h3,{id:"public",children:"Public"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Public/ElysPerceptionPlugin.h"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Public/Core/ERPPerceptionComponent.h"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Public/Core/ERPTargetable.h"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Public/Core/ERPInteractable.h"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"private",children:"Private"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Private/ElysPerceptionPlugin.cpp"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Private/Core/ERPPerceptionComponent.cpp"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Notes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Targeting/Interaction folders were removed to keep a minimal API surface."}),"\n",(0,r.jsxs)(n.li,{children:["Initiator interfaces were intentionally removed. Initiator-side rules are now ",(0,r.jsx)(n.strong,{children:"overridable functions on the perception component"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ERPHelpers"})," was removed (dead code)."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-file-by-file-responsibilities",children:"2) File-by-file responsibilities"}),"\n",(0,r.jsx)(n.h3,{id:"publicelysperceptionpluginh",children:(0,r.jsx)(n.code,{children:"Public/ElysPerceptionPlugin.h"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Declares the Unreal module interface ",(0,r.jsx)(n.code,{children:"FElysPerceptionPluginModule"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"No gameplay logic."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"privateelysperceptionplugincpp",children:(0,r.jsx)(n.code,{children:"Private/ElysPerceptionPlugin.cpp"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implements module startup/shutdown."}),"\n",(0,r.jsx)(n.li,{children:"No gameplay logic."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"publiccoreerptargetableh",children:(0,r.jsx)(n.code,{children:"Public/Core/ERPTargetable.h"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Legacy opt-in interface"})," (for backward compatibility or custom use)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Not directly used by the core multi-channel perception system."}),"\n",(0,r.jsx)(n.li,{children:"Can be consumed by custom filters/samplers if needed."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"publiccoreerpinteractableh",children:(0,r.jsx)(n.code,{children:"Public/Core/ERPInteractable.h"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Legacy opt-in interface"})," (for backward compatibility or custom use)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Not directly used by the core multi-channel perception system."}),"\n",(0,r.jsx)(n.li,{children:"Can be consumed by custom filters/samplers if needed."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"publiccoreerpperceptioncomponenth",children:(0,r.jsx)(n.code,{children:"Public/Core/ERPPerceptionComponent.h"})}),"\n",(0,r.jsx)(n.p,{children:"Defines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"UERPPerceptionComponent"})," \u2014 the main runtime system implementing pure multi-channel perception."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Core State:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CurrentBestByChannel"})," \u2014 TMap<FName, TObjectPtr<AActor>> tracking current best candidate per channel"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PrevBestByChannel"})," \u2014 TMap<FName, TObjectPtr<AActor>> tracking previous best candidate per channel"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"API:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GetChannelCandidate(FName ChannelId)"})," \u2014 Returns the current best candidate for a given channel"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HasChannelCandidate(FName ChannelId)"})," \u2014 True if this channel currently has a candidate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GetAllChannelCandidates(...)"})," \u2014 Snapshot of all current candidates across all channels"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ChannelPipelines"})," \u2014 Array of FERPChannelPipeline defining each evaluation channel"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"DefaultSamplingRange"})," \u2014 Default sampling range passed to samplers (customizable per channel)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Events (Generic multi-channel only):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"OnChannelCandidateAcquired(FName ChannelId, AActor* Candidate)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"OnChannelCandidateLost(FName ChannelId, AActor* Candidate)"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Perception Context Providers:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GetPerceptionAimRay(OutOrigin, OutDirection)"})," \u2014 BlueprintNativeEvent for custom camera setup"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"GetScreenReferenceNdc(OutScreenReferenceNdc)"})," \u2014 Optional screen-space reference point for scorers"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"privatecoreerpperceptioncomponentcpp",children:(0,r.jsx)(n.code,{children:"Private/Core/ERPPerceptionComponent.cpp"})}),"\n",(0,r.jsx)(n.p,{children:"Implements the runtime behavior:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Continuous evaluation (tick)"}),"\n",(0,r.jsx)(n.li,{children:"Per-channel pipeline execution (sample \u2192 filter \u2192 score \u2192 select)"}),"\n",(0,r.jsx)(n.li,{children:"Multi-channel state tracking (CurrentBestByChannel, PrevBestByChannel)"}),"\n",(0,r.jsx)(n.li,{children:"Change detection and event emission (acquired/lost per channel)"}),"\n",(0,r.jsx)(n.li,{children:"Perception context building (aim ray, screen reference, viewport info)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The component is ",(0,r.jsx)(n.strong,{children:"pure perception only"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No cross-channel priority logic"}),"\n",(0,r.jsx)(n.li,{children:"No winner/focus semantics"}),"\n",(0,r.jsx)(n.li,{children:"No lock state"}),"\n",(0,r.jsx)(n.li,{children:"No gameplay actions"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-architecture-overview",children:"3) Architecture overview"}),"\n",(0,r.jsx)(n.h3,{id:"core-concept-pure-perception-multi-channel",children:"Core concept: Pure Perception, Multi-Channel"}),"\n",(0,r.jsxs)(n.p,{children:["A single component (",(0,r.jsx)(n.code,{children:"UERPPerceptionComponent"}),") evaluates multiple independent channels every tick."]}),"\n",(0,r.jsx)(n.p,{children:"Each channel:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Has a unique ",(0,r.jsx)(n.code,{children:"FName"}),' identifier (e.g., "Combat", "Interaction", "Ally")']}),"\n",(0,r.jsx)(n.li,{children:"Executes its own pipeline: Sample \u2192 Filter \u2192 Score \u2192 Select"}),"\n",(0,r.jsx)(n.li,{children:"Tracks its own best candidate independently"}),"\n",(0,r.jsx)(n.li,{children:"Emits generic events when its candidate changes"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"No cross-channel logic:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No winner/focus/priority between channels"}),"\n",(0,r.jsx)(n.li,{children:"No lock state"}),"\n",(0,r.jsx)(n.li,{children:"Each channel is completely independent"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"multi-channel-state-management",children:"Multi-channel state management"}),"\n",(0,r.jsx)(n.p,{children:"Internal state is stored in two parallel maps:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"TMap<FName, TObjectPtr<AActor>> CurrentBestByChannel;\nTMap<FName, TObjectPtr<AActor>> PrevBestByChannel;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Every tick:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["For each configured channel in ",(0,r.jsx)(n.code,{children:"ChannelPipelines"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Execute the channel's pipeline to find the best candidate"}),"\n",(0,r.jsxs)(n.li,{children:["Compare with ",(0,r.jsx)(n.code,{children:"CurrentBestByChannel[ChannelId]"})]}),"\n",(0,r.jsx)(n.li,{children:"If changed: emit events and update maps"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PrevBestByChannel"})," preserves the previous frame's state for change detection"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Event flow per channel:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If new candidate differs from current: emit ",(0,r.jsx)(n.code,{children:"OnChannelCandidateLost"})," (if previous existed), then ",(0,r.jsx)(n.code,{children:"OnChannelCandidateAcquired"})," (if new exists)"]}),"\n",(0,r.jsxs)(n.li,{children:["Each event passes ",(0,r.jsx)(n.code,{children:"(FName ChannelId, AActor* Candidate)"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-pipeline-execution-runtime-details",children:"4) Pipeline execution (runtime details)"}),"\n",(0,r.jsx)(n.h3,{id:"channel-pipeline-architecture",children:"Channel pipeline architecture"}),"\n",(0,r.jsxs)(n.p,{children:["Each channel in ",(0,r.jsx)(n.code,{children:"ChannelPipelines"})," defines:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sampler"})," \u2014 Collects candidate actors from the world (e.g., sphere overlap, box trace)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Filters"})," \u2014 Array of filters to validate/reject candidates (e.g., interface checks, line-of-sight)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scorer"})," \u2014 Assigns a numeric score to each candidate (e.g., distance, screen-space proximity)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selector"})," \u2014 Chooses the best candidate from scored results (e.g., lowest score, highest score)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"evaluation-flow-per-channel",children:"Evaluation flow per channel"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sample:"})," Sampler produces a list of actor candidates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Filter:"})," Each filter validates candidates (actors failing any filter are rejected)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Score:"})," Scorer assigns a numeric value to each remaining candidate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Select:"})," Selector picks the best candidate based on scoring strategy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compare:"})," Result is compared with ",(0,r.jsx)(n.code,{children:"CurrentBestByChannel[ChannelId]"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Emit:"})," If changed, emit ",(0,r.jsx)(n.code,{children:"OnChannelCandidateLost"})," and/or ",(0,r.jsx)(n.code,{children:"OnChannelCandidateAcquired"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"perception-context",children:"Perception context"}),"\n",(0,r.jsxs)(n.p,{children:["The component builds a ",(0,r.jsx)(n.code,{children:"FERPPerceptionContext"})," struct passed to all pipeline stages:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Origin & Direction:"})," From ",(0,r.jsx)(n.code,{children:"GetPerceptionAimRay()"})," (default: owner view point)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Screen Reference:"})," From ",(0,r.jsx)(n.code,{children:"GetScreenReferenceNdc()"})," (optional, for screen-space scorers)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Viewport Size:"})," If ",(0,r.jsx)(n.code,{children:"bProvideViewportInfoWhenAvailable"})," is true (for local PlayerController)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sampling Range:"})," From ",(0,r.jsx)(n.code,{children:"DefaultSamplingRange"})," (samplers may ignore or override)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"extensibility",children:"Extensibility"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Override ",(0,r.jsx)(n.code,{children:"GetPerceptionAimRay"})," in BP/C++ for custom camera setup"]}),"\n",(0,r.jsxs)(n.li,{children:["Override ",(0,r.jsx)(n.code,{children:"GetScreenReferenceNdc"})," for custom screen-space reference (e.g., mouse cursor)"]}),"\n",(0,r.jsx)(n.li,{children:"Create custom samplers, filters, scorers, and selectors as needed"}),"\n",(0,r.jsx)(n.li,{children:"Define any number of channels with unique pipeline configurations"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-events-rules-and-expectations",children:"5) Events: rules and expectations"}),"\n",(0,r.jsx)(n.h3,{id:"generic-multi-channel-events",children:"Generic multi-channel events"}),"\n",(0,r.jsx)(n.p,{children:"The component emits only two event types, both generic and channel-agnostic:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.em,{children:[(0,r.jsx)(n.em,{children:"OnChannelCandidateAcquired(FName ChannelId, AActor"})," Candidate)"]}),"*"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fired when a channel acquires a new best candidate"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ChannelId"})," identifies which channel changed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Candidate"})," is the new best actor (never null)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.em,{children:[(0,r.jsx)(n.em,{children:"OnChannelCandidateLost(FName ChannelId, AActor"})," Candidate)"]}),"*"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fired when a channel loses its previous best candidate"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ChannelId"})," identifies which channel changed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Candidate"})," is the actor that was lost (never null)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"event-ordering",children:"Event ordering"}),"\n",(0,r.jsx)(n.p,{children:"When a channel's best candidate changes from ActorA to ActorB:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OnChannelCandidateLost(ChannelId, ActorA)"})," fires first"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OnChannelCandidateAcquired(ChannelId, ActorB)"})," fires second"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When a channel's best candidate changes from ActorA to none:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OnChannelCandidateLost(ChannelId, ActorA)"})," fires"]}),"\n",(0,r.jsx)(n.li,{children:"No acquisition event (no new candidate)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When a channel's best candidate changes from none to ActorA:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"No loss event (no previous candidate)"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OnChannelCandidateAcquired(ChannelId, ActorA)"})," fires"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"no-focuswinner-semantics",children:"No focus/winner semantics"}),"\n",(0,r.jsxs)(n.p,{children:["Unlike legacy systems, these events carry ",(0,r.jsx)(n.strong,{children:"no priority/focus information"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["No ",(0,r.jsx)(n.code,{children:"bHasCurrentFocus"})," parameter"]}),"\n",(0,r.jsx)(n.li,{children:"No focus-status-changed events"}),"\n",(0,r.jsx)(n.li,{children:"No winner code"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If cross-channel priority is needed, implement it in gameplay code by listening to multiple channels."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-feature-set-recap",children:"6) Feature set recap"}),"\n",(0,r.jsx)(n.h3,{id:"pure-perception-channel-agnostic",children:"Pure perception (channel-agnostic)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Multi-channel evaluation via configurable pipelines"}),"\n",(0,r.jsx)(n.li,{children:"Independent best candidate tracking per channel"}),"\n",(0,r.jsx)(n.li,{children:"Generic events (acquired/lost) with channel identification"}),"\n",(0,r.jsx)(n.li,{children:"No built-in gameplay semantics (no target/interaction/focus/lock)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"perception-context-providers",children:"Perception context providers"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pluggable aim ray source (",(0,r.jsx)(n.code,{children:"GetPerceptionAimRay"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Optional screen-space reference (",(0,r.jsx)(n.code,{children:"GetScreenReferenceNdc"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Viewport info passthrough for screen-space scorers"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-extensibility",children:"Pipeline extensibility"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Custom samplers (how to find candidates)"}),"\n",(0,r.jsx)(n.li,{children:"Custom filters (how to validate candidates)"}),"\n",(0,r.jsx)(n.li,{children:"Custom scorers (how to rank candidates)"}),"\n",(0,r.jsx)(n.li,{children:"Custom selectors (how to choose the best)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"configuration-flexibility",children:"Configuration flexibility"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Define any number of channels with unique ",(0,r.jsx)(n.code,{children:"FName"})," identifiers"]}),"\n",(0,r.jsx)(n.li,{children:"Each channel has independent pipeline configuration"}),"\n",(0,r.jsx)(n.li,{children:"No hardcoded channel types or priorities"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-non-goals-intentionally-excluded",children:"7) Non-goals (intentionally excluded)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No cross-channel priority/winner logic"}),"\n",(0,r.jsx)(n.li,{children:"No focus semantics"}),"\n",(0,r.jsx)(n.li,{children:"No lock state or target freezing"}),"\n",(0,r.jsx)(n.li,{children:"No UI prompts or input binding"}),"\n",(0,r.jsx)(n.li,{children:"No gameplay orchestration or action execution"}),"\n",(0,r.jsx)(n.li,{children:"No GAS dependencies"}),"\n",(0,r.jsx)(n.li,{children:'No hardcoded channel types (e.g., "Target", "Interaction")'}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453(e,n,i){i.d(n,{R:()=>s,x:()=>t});var l=i(6540);const r={},c=l.createContext(r);function s(e){const n=l.useContext(c);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),l.createElement(c.Provider,{value:n},e.children)}}}]);