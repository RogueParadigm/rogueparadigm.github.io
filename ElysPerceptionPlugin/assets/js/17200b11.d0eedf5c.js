"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[409],{6196(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"ArchitectureDeepDive","title":"Architecture Deep Dive","description":"This document provides an in-depth explanation of the ElysPerceptionPlugin\'s Pipeline architecture.","source":"@site/../Documentation/ArchitectureDeepDive.md","sourceDirName":".","slug":"/ArchitectureDeepDive","permalink":"/ElysPerceptionPlugin/ArchitectureDeepDive","draft":false,"unlisted":false,"editUrl":"https://github.com/RogueParadigm/ElysPerceptionPlugin/tree/main/Documentation/../Documentation/ArchitectureDeepDive.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"ArchitectureDeepDive","title":"Architecture Deep Dive","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Pipeline Guide","permalink":"/ElysPerceptionPlugin/PipelineGuide"},"next":{"title":"Advanced Customization Guide","permalink":"/ElysPerceptionPlugin/AdvancedCustomization"}}');var s=r(4848),t=r(8453);const l={id:"ArchitectureDeepDive",title:"Architecture Deep Dive",sidebar_position:4},c="Architecture Deep Dive",o={},a=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"What is the Pipeline System?",id:"what-is-the-pipeline-system",level:3},{value:"Why Does It Exist?",id:"why-does-it-exist",level:3},{value:"Design Philosophy",id:"design-philosophy",level:3},{value:"Architecture Diagram",id:"architecture-diagram",level:2},{value:"Pipeline Flow",id:"pipeline-flow",level:2},{value:"Stage 1: Sampler",id:"stage-1-sampler",level:3},{value:"Stage 2: Filters",id:"stage-2-filters",level:3},{value:"Stage 3: Scorers",id:"stage-3-scorers",level:3},{value:"Score conventions (important)",id:"score-conventions-important",level:4},{value:"Stage 4: Aggregator",id:"stage-4-aggregator",level:3},{value:"Stage 5: Resolver",id:"stage-5-resolver",level:3},{value:"Context System",id:"context-system",level:2},{value:"FERPPerceptionContext",id:"ferpperceptioncontext",level:3},{value:"Context Building",id:"context-building",level:3},{value:"Context Provider Interface",id:"context-provider-interface",level:3},{value:"Why Immutable?",id:"why-immutable",level:3},{value:"Multi-Channel Support",id:"multi-channel-support",level:2},{value:"Channel Independence",id:"channel-independence",level:3},{value:"Shared Context",id:"shared-context",level:3},{value:"Adding Custom Channels",id:"adding-custom-channels",level:3},{value:"Extensibility",id:"extensibility",level:2},{value:"Creating Custom Pipeline Components",id:"creating-custom-pipeline-components",level:3},{value:"Custom Sampler",id:"custom-sampler",level:3},{value:"Custom Filter",id:"custom-filter",level:3},{value:"Custom Scorer",id:"custom-scorer",level:3},{value:"Custom Aggregator",id:"custom-aggregator",level:3},{value:"Custom Resolver",id:"custom-resolver",level:3},{value:"Blueprint Custom Components",id:"blueprint-custom-components",level:3},{value:"Best Practices for Custom Components",id:"best-practices-for-custom-components",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"architecture-deep-dive",children:"Architecture Deep Dive"})}),"\n",(0,s.jsx)(n.p,{children:"This document provides an in-depth explanation of the ElysPerceptionPlugin's Pipeline architecture."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#architecture-diagram",children:"Architecture Diagram"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#pipeline-flow",children:"Pipeline Flow"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#context-system",children:"Context System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#multi-channel-support",children:"Multi-Channel Support"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#extensibility",children:"Extensibility"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-the-pipeline-system",children:"What is the Pipeline System?"}),"\n",(0,s.jsxs)(n.p,{children:["The Pipeline system is a ",(0,s.jsx)(n.strong,{children:"modular, data-driven architecture"})," for evaluating perception candidates. Instead of hardcoded perception logic, the system uses a configurable series of stages that can be mixed and matched to create custom behavior."]}),"\n",(0,s.jsx)(n.h3,{id:"why-does-it-exist",children:"Why Does It Exist?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Problems with traditional perception systems:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monolithic code that's hard to customize"}),"\n",(0,s.jsx)(n.li,{children:"Mixing concerns (sampling, filtering, scoring)"}),"\n",(0,s.jsx)(n.li,{children:"Difficult to extend without modifying engine code"}),"\n",(0,s.jsx)(n.li,{children:"One-size-fits-all approach doesn't fit all use cases"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pipeline system benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Separation of Concerns"}),": Each stage has one job"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Composability"}),": Mix default and custom components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reusability"}),": Same components work across channels"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extensibility"}),": Add custom logic without touching core code"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration"}),": Designers can tweak in editor without C++"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Over Code"}),": Behavior is configured, not coded"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable Context"}),": All stages read from same snapshot"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pure Functions"}),": Stages don't modify state, only evaluate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Independence"}),": Multiple channels run in parallel"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Opt-In"}),": Targets choose to participate"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"architecture-diagram",children:"Architecture Diagram"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pipeline flow (per channel):"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Build ",(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," (origin, forward, aim ray, viewport info, owner)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sampler"})," gathers candidates (array of actors)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Filters"})," reject invalid candidates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scorers"})," assign scores (lower is better)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Aggregator"})," combines scores (if multiple)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resolver"})," selects best candidate for that channel"]}),"\n",(0,s.jsx)(n.li,{children:"Component fires channel-specific events (OnChannelCandidateAcquired/Lost)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Defaults at a glance (Target channel):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Sampler: ",(0,s.jsx)(n.code,{children:"ERPSphereOverlapSampler"})," (TraceChannel: Visibility, ignore context actor)"]}),"\n",(0,s.jsxs)(n.li,{children:["Filters: ",(0,s.jsx)(n.code,{children:"ERPTargetableFilter"})]}),"\n",(0,s.jsxs)(n.li,{children:["Scorers: ",(0,s.jsx)(n.code,{children:"ERPDistanceScorer"})," (normalize by range)"]}),"\n",(0,s.jsxs)(n.li,{children:["Aggregator: ",(0,s.jsx)(n.code,{children:"ERPIdentityAggregator"})," (pass-through)"]}),"\n",(0,s.jsxs)(n.li,{children:["Resolver: ",(0,s.jsx)(n.code,{children:"ERPLowestScoreResolver"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Reuse the same pattern for Interaction (swap filters/scorers as needed) or add custom subclasses for any stage."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-flow",children:"Pipeline Flow"}),"\n",(0,s.jsx)(n.h3,{id:"stage-1-sampler",children:"Stage 1: Sampler"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Collect potential candidate actors from the world."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," - Perception context"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float Range"})," - Maximum detection range"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TArray<AActor*>"})," - All candidate actors"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UFUNCTION(BlueprintNativeEvent, Category = "ElysPerception|Pipeline")\r\nvoid Sample(const FERPPerceptionContext& Context, float Range, TArray<AActor*>& OutCandidates) const;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Query the world for actors (overlap, ray cast, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Return raw list without filtering"}),"\n",(0,s.jsx)(n.li,{children:"Should be fast and broad"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sphere overlap around origin"}),"\n",(0,s.jsx)(n.li,{children:"Line trace in forward direction"}),"\n",(0,s.jsx)(n.li,{children:"Query spatial hash/octree"}),"\n",(0,s.jsx)(n.li,{children:"Get actors from GameState"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPSphereOverlapSampler"})," - Sphere overlap query"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-2-filters",children:"Stage 2: Filters"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Eliminate invalid candidates. ALL filters must pass for a candidate to proceed."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," - Perception context"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AActor* Candidate"})," - Single candidate to test"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bool"})," - True if candidate passes, false if rejected"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UFUNCTION(BlueprintNativeEvent, Category = "ElysPerception|Pipeline")\r\nbool Passes(const FERPPerceptionContext& Context, AActor* Candidate) const;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fast rejection of invalid candidates"}),"\n",(0,s.jsx)(n.li,{children:"Binary decision (pass/fail)"}),"\n",(0,s.jsx)(n.li,{children:"No scoring, just validation"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check if actor implements required interface"}),"\n",(0,s.jsx)(n.li,{children:"Verify actor is alive"}),"\n",(0,s.jsx)(n.li,{children:"Check line of sight"}),"\n",(0,s.jsx)(n.li,{children:"Validate actor state"}),"\n",(0,s.jsx)(n.li,{children:"Range check"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPTargetableFilter"})," - Requires IERPTargetable interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPInteractableFilter"})," - Requires IERPInteractable interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPImplementsInterfaceFilter"})," - Generic interface check"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution:"}),"\r\nFilters run in ",(0,s.jsx)(n.strong,{children:"sequence"}),". If any filter returns false, the candidate is rejected immediately (short-circuit evaluation)."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-3-scorers",children:"Stage 3: Scorers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Assign numerical scores to candidates. Multiple scorers can evaluate different aspects."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," - Perception context"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AActor* Candidate"})," - Candidate to score"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float"})," - Score value (lower is better by default)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UFUNCTION(BlueprintNativeEvent, Category = "ElysPerception|Pipeline")\r\nfloat Score(const FERPPerceptionContext& Context, AActor* Candidate) const;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Evaluate one aspect of the candidate"}),"\n",(0,s.jsx)(n.li,{children:"Return a numeric score where possible"}),"\n",(0,s.jsxs)(n.li,{children:["Typically a ",(0,s.jsx)(n.em,{children:"pure"})," measurement"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"score-conventions-important",children:"Score conventions (important)"}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline supports a ",(0,s.jsx)(n.strong,{children:"hard reject"})," convention for scorers."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A scorer may return ",(0,s.jsx)(n.code,{children:"ERPPipelineScore::RejectScore"})," to indicate the candidate is ",(0,s.jsx)(n.strong,{children:"invalid / rejected"})," for this scorer."]}),"\n",(0,s.jsxs)(n.li,{children:["The runner will immediately reject the candidate for the channel when any scorer returns ",(0,s.jsx)(n.code,{children:"RejectScore"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Resolvers (like ",(0,s.jsx)(n.code,{children:"UERPLowestScoreResolver"}),") ignore rejected/invalid scores."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Header:"})," ",(0,s.jsx)(n.code,{children:"Pipeline/ERPPipelineScoreConstants.h"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"namespace ERPPipelineScore\r\n{\r\n    static constexpr float RejectScore = TNumericLimits<float>::Max();\r\n    FORCEINLINE bool IsRejected(float Score);\r\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Recommendation: prefer using Filters for boolean rules, but the reject-score convention is useful for cases where the scorer cannot produce a meaningful measurement (missing viewport data, projection failure, etc.)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Distance from origin"}),"\n",(0,s.jsx)(n.li,{children:"Angle from forward vector"}),"\n",(0,s.jsx)(n.li,{children:"Screen position (viewport ellipse)"}),"\n",(0,s.jsx)(n.li,{children:"Dot product with aim ray"}),"\n",(0,s.jsx)(n.li,{children:"Custom gameplay metrics (health, threat level)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPDistanceScorer"})," - Scores based on distance (lower = closer = better)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPConeScorer"})," - Scores based on angle from forward (0 = directly ahead)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPViewportEllipseScorer"})," - Scores based on screen position"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution:"}),"\r\nAll scorers run for each candidate, producing an array of scores per candidate."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-4-aggregator",children:"Stage 4: Aggregator"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Combine multiple scores into a single final score per candidate."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TArray<float> Scores"})," - All scores for one candidate"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float"})," - Single aggregated score"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UFUNCTION(BlueprintNativeEvent, Category = "ElysPerception|Pipeline")\r\nfloat Aggregate(const TArray<float>& Scores) const;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduce multiple scores to one value"}),"\n",(0,s.jsx)(n.li,{children:"Handle empty arrays (return default)"}),"\n",(0,s.jsx)(n.li,{children:"Define how scores combine"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pass through single score"}),"\n",(0,s.jsx)(n.li,{children:"Sum scores (additive)"}),"\n",(0,s.jsx)(n.li,{children:"Multiply scores (multiplicative)"}),"\n",(0,s.jsx)(n.li,{children:"Weighted average"}),"\n",(0,s.jsx)(n.li,{children:"Min/max of scores"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPIdentityAggregator"})," - Returns first score (for single scorer)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPAdditiveAggregator"})," - Sums all scores"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPMultiplicativeAggregator"})," - Multiplies all scores"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," If you have only one scorer, use ",(0,s.jsx)(n.code,{children:"UERPIdentityAggregator"})," for efficiency."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-5-resolver",children:"Stage 5: Resolver"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Select the winning candidate from all scored candidates."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TArray<FERPPipelineScoredCandidate>"})," - All candidates with final scores"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bool"})," - True if a best candidate was found"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPipelineScoredCandidate& OutBest"})," - The best candidate"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UFUNCTION(BlueprintNativeEvent, Category = "ElysPerception|Pipeline")\r\nbool Resolve(const TArray<FERPPipelineScoredCandidate>& ScoredCandidates, FERPPipelineScoredCandidate& OutBest) const;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Determine which candidate is best"}),"\n",(0,s.jsx)(n.li,{children:"Handle empty arrays (return false)"}),"\n",(0,s.jsx)(n.li,{children:'Define "better" (lowest vs highest score)'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lowest score wins (distance-based)"}),"\n",(0,s.jsx)(n.li,{children:"Highest score wins (priority-based)"}),"\n",(0,s.jsx)(n.li,{children:"Closest to target value"}),"\n",(0,s.jsx)(n.li,{children:"Random selection"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPLowestScoreResolver"})," - Selects candidate with lowest score"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPHighestScoreResolver"})," - Selects candidate with highest score"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution:"}),"\r\nResolver runs once per channel with all scored candidates."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"context-system",children:"Context System"}),"\n",(0,s.jsx)(n.h3,{id:"ferpperceptioncontext",children:"FERPPerceptionContext"}),"\n",(0,s.jsxs)(n.p,{children:["The context is an ",(0,s.jsx)(n.strong,{children:"immutable snapshot"})," of perception data, built once per tick and shared across all channels."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provide consistent data to all pipeline stages"}),"\n",(0,s.jsx)(n.li,{children:"Avoid repeated queries (GetActorLocation, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Decouple perception from specific owner types"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Contents:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct FERPPerceptionContext\r\n{\r\n    // Origin of perception (typically owner location)\r\n    AActor* ContextActor;\r\n    FVector Origin;\r\n    FVector Forward;\r\n\r\n    // Optional aim ray (from camera or weapon)\r\n    bool bHasAimRay;\r\n    FVector AimOrigin;\r\n    FVector AimDirection;\r\n\r\n    // Optional viewport projection (for screen-space scoring)\r\n    bool bHasViewportProjection;\r\n    FVector2D ViewportCenterPx;\r\n    float ViewportEllipseHalfWidthPx;\r\n    float ViewportEllipseHalfHeightPx;\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"context-building",children:"Context Building"}),"\n",(0,s.jsx)(n.p,{children:"The perception component builds the context each tick:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Get Owner Actor"})," - The component's owner (PlayerController, Pawn)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Get View Point"})," - Location and rotation for perception"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extract Aim Ray"})," - Optional camera or weapon aim"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Calculate Viewport Data"})," - For screen-space scoring (PlayerController only)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"context-provider-interface",children:"Context Provider Interface"}),"\n",(0,s.jsxs)(n.p,{children:["Components implement ",(0,s.jsx)(n.code,{children:"IERPPerceptionContextProvider"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class IERPPerceptionContextProvider\r\n{\r\n    UFUNCTION(BlueprintNativeEvent)\r\n    FERPPerceptionContext GetPerceptionContext() const;\r\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"This allows custom context building for specific use cases."}),"\n",(0,s.jsx)(n.h3,{id:"why-immutable",children:"Why Immutable?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Thread-safe (if needed in future)"}),"\n",(0,s.jsx)(n.li,{children:"Predictable behavior across stages"}),"\n",(0,s.jsx)(n.li,{children:"No hidden state changes"}),"\n",(0,s.jsx)(n.li,{children:"Easy to debug and test"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Implications:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pipeline stages cannot modify context"}),"\n",(0,s.jsx)(n.li,{children:"All stages see identical data"}),"\n",(0,s.jsx)(n.li,{children:"Context is rebuilt each tick"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"multi-channel-support",children:"Multi-Channel Support"}),"\n",(0,s.jsx)(n.h3,{id:"channel-independence",children:"Channel Independence"}),"\n",(0,s.jsx)(n.p,{children:"Each channel runs its own complete pipeline:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Has its own sampler, filters, scorers, aggregator, resolver"}),"\n",(0,s.jsx)(n.li,{children:"Maintains its own best candidate"}),"\n",(0,s.jsx)(n.li,{children:"Fires its own events"}),"\n",(0,s.jsx)(n.li,{children:"Independent configuration"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Target Channel: Combat targeting\r\nTargetPipeline.ChannelId = "Target";\r\nTargetPipeline.Sampler = SphereOverlapSampler;\r\nTargetPipeline.Filters = { TargetableFilter };\r\nTargetPipeline.Scorers = { DistanceScorer, ConeScorer };\r\nTargetPipeline.Aggregator = AdditiveAggregator;\r\nTargetPipeline.Resolver = LowestScoreResolver;\r\n\r\n// Interaction Channel: Door/pickup interactions\r\nInteractionPipeline.ChannelId = "Interaction";\r\nInteractionPipeline.Sampler = SphereOverlapSampler;\r\nInteractionPipeline.Filters = { InteractableFilter };\r\nInteractionPipeline.Scorers = { DistanceScorer };\r\nInteractionPipeline.Aggregator = IdentityAggregator;\r\nInteractionPipeline.Resolver = LowestScoreResolver;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"shared-context",children:"Shared Context"}),"\n",(0,s.jsxs)(n.p,{children:["While channels are independent, they ",(0,s.jsx)(n.strong,{children:"share the same context"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Same origin point"}),"\n",(0,s.jsx)(n.li,{children:"Same forward direction"}),"\n",(0,s.jsx)(n.li,{children:"Same viewport data"}),"\n",(0,s.jsx)(n.li,{children:"Built once, used by all"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures consistency and performance."}),"\n",(0,s.jsx)(n.h3,{id:"adding-custom-channels",children:"Adding Custom Channels"}),"\n",(0,s.jsx)(n.p,{children:"You can add more channels beyond Target and Interaction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Healing Target Channel\r\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Perception|Pipelines")\r\nFERPChannelPipeline HealTargetPipeline;\r\n\r\n// Custom Filter: Only friendly low-health actors\r\n// Custom Scorer: Prioritize lowest health\n'})}),"\n",(0,s.jsx)(n.p,{children:"The system supports unlimited channels, though 2-3 is typical for performance."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"extensibility",children:"Extensibility"}),"\n",(0,s.jsx)(n.h3,{id:"creating-custom-pipeline-components",children:"Creating Custom Pipeline Components"}),"\n",(0,s.jsx)(n.p,{children:"The Pipeline system is designed for extension. You can create custom implementations of any stage."}),"\n",(0,s.jsx)(n.h3,{id:"custom-sampler",children:"Custom Sampler"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Query gameplay systems instead of world"}),"\n",(0,s.jsx)(n.li,{children:"Use navmesh for AI awareness"}),"\n",(0,s.jsx)(n.li,{children:"Implement predictive sampling"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Query GameState for all pawns"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"UCLASS()\r\nclass UMyGameStateSampler : public UERPSamplerBase\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    virtual void Sample_Implementation(const FERPPerceptionContext& Context, float Range, TArray<AActor*>& OutCandidates) const override\r\n    {\r\n        UWorld* World = Context.ContextActor->GetWorld();\r\n        AGameStateBase* GameState = World->GetGameState();\r\n        \r\n        // Get all pawns from game state\r\n        for (APlayerState* PS : GameState->PlayerArray)\r\n        {\r\n            if (APawn* Pawn = PS->GetPawn())\r\n            {\r\n                if (Pawn != Context.ContextActor)\r\n                {\r\n                    float Dist = FVector::Distance(Context.Origin, Pawn->GetActorLocation());\r\n                    if (Dist <= Range)\r\n                    {\r\n                        OutCandidates.Add(Pawn);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-filter",children:"Custom Filter"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Line of sight checks"}),"\n",(0,s.jsx)(n.li,{children:"Team/faction filtering"}),"\n",(0,s.jsx)(n.li,{children:"State validation (alive, active)"}),"\n",(0,s.jsx)(n.li,{children:"Permission checks"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Line of Sight Filter"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UCLASS()\r\nclass UMyLineOfSightFilter : public UERPFilterBase\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    UPROPERTY(EditAnywhere, Category = "Filter")\r\n    TEnumAsByte<ECollisionChannel> TraceChannel = ECC_Visibility;\r\n\r\n    virtual bool Passes_Implementation(const FERPPerceptionContext& Context, AActor* Candidate) const override\r\n    {\r\n        if (!Candidate || !Context.ContextActor)\r\n            return false;\r\n\r\n        FVector Start = Context.Origin;\r\n        FVector End = Candidate->GetActorLocation();\r\n\r\n        FHitResult HitResult;\r\n        FCollisionQueryParams Params;\r\n        Params.AddIgnoredActor(Context.ContextActor);\r\n\r\n        bool bHit = Context.ContextActor->GetWorld()->LineTraceSingleByChannel(\r\n            HitResult, Start, End, TraceChannel, Params\r\n        );\r\n\r\n        // Pass if we hit the candidate or nothing\r\n        return !bHit || HitResult.GetActor() == Candidate;\r\n    }\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-scorer",children:"Custom Scorer"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gameplay-specific scoring (health, threat)"}),"\n",(0,s.jsx)(n.li,{children:"Weighted multi-factor scoring"}),"\n",(0,s.jsx)(n.li,{children:"Time-based scoring"}),"\n",(0,s.jsx)(n.li,{children:"Player preference weighting"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Health Priority Scorer"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UCLASS()\r\nclass UMyHealthPriorityScorer : public UERPScorerBase\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    UPROPERTY(EditAnywhere, Category = "Scorer")\r\n    bool bPrioritizeLowHealth = true;\r\n\r\n    virtual float Score_Implementation(const FERPPerceptionContext& Context, AActor* Candidate) const override\r\n    {\r\n        // Assuming candidates have a health component\r\n        UHealthComponent* HealthComp = Candidate->FindComponentByClass<UHealthComponent>();\r\n        if (!HealthComp)\r\n            return 1.0f; // Neutral score\r\n\r\n        float HealthPercent = HealthComp->GetHealthPercent();\r\n\r\n        // Lower health = lower score (better)\r\n        if (bPrioritizeLowHealth)\r\n            return HealthPercent; // 0.0 (critical) to 1.0 (full health)\r\n        else\r\n            return 1.0f - HealthPercent; // Prioritize high health\r\n    }\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-aggregator",children:"Custom Aggregator"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Weighted averaging"}),"\n",(0,s.jsx)(n.li,{children:"Non-linear combinations"}),"\n",(0,s.jsx)(n.li,{children:"Min/max selection"}),"\n",(0,s.jsx)(n.li,{children:"Custom math formulas"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Weighted Average Aggregator"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UCLASS()\r\nclass UMyWeightedAggregator : public UERPAggregatorBase\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    UPROPERTY(EditAnywhere, Category = "Aggregator")\r\n    TArray<float> Weights = {1.0f};\r\n\r\n    virtual float Aggregate_Implementation(const TArray<float>& Scores) const override\r\n    {\r\n        if (Scores.Num() == 0)\r\n            return 0.0f;\r\n\r\n        float WeightedSum = 0.0f;\r\n        float TotalWeight = 0.0f;\r\n\r\n        for (int32 i = 0; i < Scores.Num(); ++i)\r\n        {\r\n            float Weight = (i < Weights.Num()) ? Weights[i] : 1.0f;\r\n            WeightedSum += Scores[i] * Weight;\r\n            TotalWeight += Weight;\r\n        }\r\n\r\n        return (TotalWeight > 0.0f) ? (WeightedSum / TotalWeight) : 0.0f;\r\n    }\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-resolver",children:"Custom Resolver"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sticky targeting (prefer current target)"}),"\n",(0,s.jsx)(n.li,{children:"Random selection"}),"\n",(0,s.jsx)(n.li,{children:"Round-robin"}),"\n",(0,s.jsx)(n.li,{children:"Priority tiers"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Sticky Target Resolver"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UCLASS()\r\nclass UMyStickyResolver : public UERPResolverBase\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    UPROPERTY(EditAnywhere, Category = "Resolver")\r\n    float StickyBias = 0.1f; // 10% score advantage for current target\r\n\r\n    UPROPERTY()\r\n    AActor* LastWinner = nullptr;\r\n\r\n    virtual bool Resolve_Implementation(const TArray<FERPPipelineScoredCandidate>& ScoredCandidates, FERPPipelineScoredCandidate& OutBest) const override\r\n    {\r\n        if (ScoredCandidates.Num() == 0)\r\n            return false;\r\n\r\n        OutBest = ScoredCandidates[0];\r\n\r\n        for (const FERPPipelineScoredCandidate& Candidate : ScoredCandidates)\r\n        {\r\n            float AdjustedScore = Candidate.Score;\r\n\r\n            // Give current target a score bonus\r\n            if (Candidate.Actor == LastWinner)\r\n                AdjustedScore -= StickyBias;\r\n\r\n            if (AdjustedScore < OutBest.Score)\r\n                OutBest = Candidate;\r\n        }\r\n\r\n        // Remember winner for next frame\r\n        const_cast<UMyStickyResolver*>(this)->LastWinner = OutBest.Actor;\r\n        return true;\r\n    }\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"blueprint-custom-components",children:"Blueprint Custom Components"}),"\n",(0,s.jsxs)(n.p,{children:["You can also create custom pipeline components in ",(0,s.jsx)(n.strong,{children:"Blueprint"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Create Blueprint Class"})," derived from:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ERPSamplerBase"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ERPFilterBase"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ERPScorerBase"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ERPAggregatorBase"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ERPResolverBase"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Override Event:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Sample"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Passes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Score"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Aggregate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Resolve"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement Logic"})," using Blueprint nodes"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use in Pipeline"})," by selecting your BP class"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Blueprint Scorer for checking actor tags"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Event Score\r\n  \u2192 Get Actor Tags (Candidate)\r\n  \u2192 Contains: "Priority"\r\n    True: \u2192 Return 0.0 (highest priority)\r\n    False: \u2192 Return 1.0 (normal priority)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"best-practices-for-custom-components",children:"Best Practices for Custom Components"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Keep Stages Pure"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Don't modify candidates or context"}),"\n",(0,s.jsx)(n.li,{children:"Only read and evaluate"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimize for Performance"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Filters run per-candidate, keep them fast"}),"\n",(0,s.jsx)(n.li,{children:"Cache expensive calculations"}),"\n",(0,s.jsx)(n.li,{children:"Avoid allocations in hot path"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Normalize Scores"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use 0.0-1.0 range when possible"}),"\n",(0,s.jsx)(n.li,{children:"Document expected ranges"}),"\n",(0,s.jsx)(n.li,{children:"Make combinable with other scorers"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Handle Edge Cases"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Null checks"}),"\n",(0,s.jsx)(n.li,{children:"Empty arrays"}),"\n",(0,s.jsx)(n.li,{children:"Invalid context"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Document Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"UPROPERTY"})," meta tags"]}),"\n",(0,s.jsx)(n.li,{children:"Add tooltips"}),"\n",(0,s.jsx)(n.li,{children:"Provide sensible defaults"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Test Independently"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unit test each component"}),"\n",(0,s.jsx)(n.li,{children:"Test with empty inputs"}),"\n",(0,s.jsx)(n.li,{children:"Verify with different contexts"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"The Pipeline architecture provides:"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Modularity"})," - Mix and match components",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Flexibility"})," - Configure without code",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Extensibility"})," - Add custom logic easily",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Performance"})," - Optimize individual stages",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Clarity"})," - Clear separation of concerns",(0,s.jsx)(n.br,{}),"\n","\u2705 ",(0,s.jsx)(n.strong,{children:"Reusability"})," - Share components across channels"]}),"\n",(0,s.jsxs)(n.p,{children:["For API details, see ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/API-Reference",children:"API-Reference.md"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Previous:"})," ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/PipelineGuide",children:"Pipeline Guide"})," | ",(0,s.jsx)(n.strong,{children:"Next:"})," ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/AdvancedCustomization",children:"Advanced Customization"})," | ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/",children:"Documentation Home"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>l,x:()=>c});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);