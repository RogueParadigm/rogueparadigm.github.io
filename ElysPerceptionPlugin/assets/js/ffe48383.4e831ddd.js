"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[620],{829(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"PipelineSystem","title":"Pipeline System","description":"Deep dive into the ElysPerceptionPlugin\'s modular Pipeline architecture.","source":"@site/../Documentation/PipelineSystem.md","sourceDirName":".","slug":"/PipelineSystem","permalink":"/ElysPerceptionPlugin/PipelineSystem","draft":false,"unlisted":false,"editUrl":"https://github.com/RogueParadigm/ElysPerceptionPlugin/tree/main/Documentation/../Documentation/PipelineSystem.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"PipelineSystem","title":"Pipeline System","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Setup Guide","permalink":"/ElysPerceptionPlugin/SetupGuide"},"next":{"title":"Interaction Guide","permalink":"/ElysPerceptionPlugin/InteractionGuide"}}');var s=i(4848),l=i(8453);const t={id:"PipelineSystem",title:"Pipeline System",sidebar_position:3},c=void 0,o={},d=[{value:"Overview",id:"overview",level:2},{value:"Why Pipeline Architecture?",id:"why-pipeline-architecture",level:3},{value:"Core Philosophy",id:"core-philosophy",level:3},{value:"Pipeline Flow",id:"pipeline-flow",level:2},{value:"Execution Flow",id:"execution-flow",level:3},{value:"Pipeline Stages",id:"pipeline-stages",level:2},{value:"Stage 1: Sampler",id:"stage-1-sampler",level:3},{value:"Stage 2: Filters",id:"stage-2-filters",level:3},{value:"Stage 3: Scorers",id:"stage-3-scorers",level:3},{value:"Stage 4: Aggregator",id:"stage-4-aggregator",level:3},{value:"Stage 5: Resolver",id:"stage-5-resolver",level:3},{value:"Context System",id:"context-system",level:2},{value:"FERPPerceptionContext",id:"ferpperceptioncontext",level:3},{value:"Context Building",id:"context-building",level:3},{value:"Why Immutable?",id:"why-immutable",level:3},{value:"Multi-Channel Support",id:"multi-channel-support",level:2},{value:"Channel Independence",id:"channel-independence",level:3},{value:"Shared Context",id:"shared-context",level:3},{value:"Adding Custom Channels",id:"adding-custom-channels",level:3},{value:"Performance",id:"performance",level:2},{value:"Per Tick Cost",id:"per-tick-cost",level:3},{value:"Optimization Tips",id:"optimization-tips",level:3},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Deep dive into the ElysPerceptionPlugin's modular Pipeline architecture."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The Pipeline is a modular, data-driven architecture for evaluating perception candidates. Instead of hardcoded perception logic, you configure a series of stages that can be mixed and matched."}),"\n",(0,s.jsx)(n.h3,{id:"why-pipeline-architecture",children:"Why Pipeline Architecture?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Traditional perception problems:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monolithic code that's hard to customize"}),"\n",(0,s.jsx)(n.li,{children:"Mixing concerns (sampling, filtering, scoring)"}),"\n",(0,s.jsx)(n.li,{children:"One-size-fits-all approach"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pipeline benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Separation of concerns (each stage has one job)"}),"\n",(0,s.jsx)(n.li,{children:"Composability (mix default and custom components)"}),"\n",(0,s.jsx)(n.li,{children:"Reusability (same components across channels)"}),"\n",(0,s.jsx)(n.li,{children:"Extensibility (add custom logic without touching core)"}),"\n",(0,s.jsx)(n.li,{children:"Designer-friendly configuration"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"core-philosophy",children:"Core Philosophy"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Over Code:"})," Behavior is configured, not coded"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable Context:"})," All stages read from same snapshot"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pure Functions:"})," Stages evaluate without modifying state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Independence:"})," Multiple channels run in parallel"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Opt-In:"})," Targets choose to participate via interfaces"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-flow",children:"Pipeline Flow"}),"\n",(0,s.jsx)(n.p,{children:"Every tick, the perception component:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Builds Context"})," - Snapshot of player position, view direction, viewport info"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runs Each Channel"})," - Target, Interaction, custom channels independently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Determines Focus"})," - Which channel's result gets priority"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fires Events"})," - Notifies your game of changes"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UERPPerceptionComponent::TickComponent()\r\n  \u2193\r\nBuildContext()\r\n  \u2192 Get owner actor\r\n  \u2192 Get view point (position, rotation)\r\n  \u2192 Extract aim ray\r\n  \u2192 Calculate viewport data\r\n  \u2192 Create FERPPerceptionContext\r\n  \u2193\r\nFor each channel:\r\n  \u2193\r\n  Execute Pipeline:\r\n    \u2192 Sampler: Gather candidates\r\n    \u2192 Filters: Reject invalid\r\n    \u2192 Scorers: Assign scores\r\n    \u2192 Aggregator: Combine scores\r\n    \u2192 Resolver: Select best\r\n  \u2193\r\n  Store result (best candidate + score)\r\n  \u2193\r\nDetermine Focus Winner\r\nFire Events (OnCandidateAcquired/Lost)\r\nUpdate Debug Visualization\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-stages",children:"Pipeline Stages"}),"\n",(0,s.jsx)(n.h3,{id:"stage-1-sampler",children:"Stage 1: Sampler"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Collect potential candidate actors from the world."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," - Perception context"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float Range"})," - Maximum detection range"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TArray<AActor*>"})," - All candidate actors"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void Sample(const FERPPerceptionContext& Context, float Range, TArray<AActor*>& OutCandidates) const;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Query world for actors (overlap, ray cast)"}),"\n",(0,s.jsx)(n.li,{children:"Return raw list without filtering"}),"\n",(0,s.jsx)(n.li,{children:"Should be fast and broad"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPSphereOverlapSampler"})," - Sphere overlap query"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Sampler: ERPSphereOverlapSampler\r\n  - Trace Channel: Visibility\r\n  - Actor Class: Character\r\n  - Ignore Context Actor: \u2713\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-2-filters",children:"Stage 2: Filters"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Eliminate invalid candidates. ALL filters must pass."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," - Perception context"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AActor* Candidate"})," - Single candidate to test"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bool"})," - True if passes, false if rejected"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool Passes(const FERPPerceptionContext& Context, AActor* Candidate) const;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fast rejection of invalid candidates"}),"\n",(0,s.jsx)(n.li,{children:"Binary decision (pass/fail)"}),"\n",(0,s.jsx)(n.li,{children:"No scoring, just validation"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPTargetableFilter"})," - Requires IERPTargetable interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPInteractableFilter"})," - Requires IERPInteractable interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPDistanceFilter"})," - Range-based filtering"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution:"}),"\r\nFilters run in sequence with short-circuit evaluation. If any filter returns false, candidate is rejected immediately."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check if actor implements required interface"}),"\n",(0,s.jsx)(n.li,{children:"Verify actor is alive"}),"\n",(0,s.jsx)(n.li,{children:"Check line of sight"}),"\n",(0,s.jsx)(n.li,{children:"Range validation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-3-scorers",children:"Stage 3: Scorers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Assign numerical scores to candidates. Multiple scorers evaluate different aspects."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPerceptionContext"})," - Perception context"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AActor* Candidate"})," - Candidate to score"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float"})," - Normalized score (typically 0.0-1.0)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float Score(const FERPPerceptionContext& Context, AActor* Candidate) const;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Evaluate one aspect of candidate"}),"\n",(0,s.jsx)(n.li,{children:"Return normalized score where possible"}),"\n",(0,s.jsx)(n.li,{children:"Should not eliminate candidates (use Filters)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPDistanceScorer"})," - Scores by distance (lower = closer = better)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPConeScorer"})," - Scores by angle from forward"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPViewportEllipseScorer"})," - Scores by screen position"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution:"}),"\r\nAll scorers run for each candidate, producing an array of scores per candidate."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Score Convention:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lower scores are better (by convention)"}),"\n",(0,s.jsx)(n.li,{children:"Typically normalized to 0.0-1.0"}),"\n",(0,s.jsx)(n.li,{children:"Ensure all scorers share same convention"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Candidate A: Distance 500 \u2192 score 0.25\r\nCandidate B: Distance 1000 \u2192 score 0.5\r\nResult: A wins (0.25 < 0.5)\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-4-aggregator",children:"Stage 4: Aggregator"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Combine multiple scores into single final score per candidate."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TArray<float> Scores"})," - All scores for one candidate"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"float"})," - Single aggregated score"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float Aggregate(const TArray<float>& Scores) const;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduce multiple scores to one value"}),"\n",(0,s.jsx)(n.li,{children:"Handle empty arrays"}),"\n",(0,s.jsx)(n.li,{children:"Define how scores combine"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPIdentityAggregator"})," - Returns first score (for single scorer)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPAdditiveAggregator"})," - Sums all scores"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPMultiplicativeAggregator"})," - Multiplies all scores"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Candidate A scores: [0.3 (distance), 0.2 (angle)]\r\nCandidate B scores: [0.5 (distance), 0.1 (angle)]\r\n\r\nAdditive Aggregator:\r\n  A: 0.3 + 0.2 = 0.5\r\n  B: 0.5 + 0.1 = 0.6\r\n  \u2192 A wins (lower score)\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-5-resolver",children:"Stage 5: Resolver"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Select the winning candidate from all scored candidates."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Input:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TArray<FERPPipelineScoredCandidate>"})," - All candidates with scores"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bool"})," - True if winner found"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FERPPipelineScoredCandidate& OutBest"})," - The winner"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool Resolve(const TArray<FERPPipelineScoredCandidate>& ScoredCandidates, FERPPipelineScoredCandidate& OutBest) const;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Responsibility:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Determine which candidate wins"}),"\n",(0,s.jsx)(n.li,{children:"Handle empty arrays (return false)"}),"\n",(0,s.jsx)(n.li,{children:'Define "better" (lowest vs highest)'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPLowestScoreResolver"})," - Selects lowest score"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UERPHighestScoreResolver"})," - Selects highest score"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"context-system",children:"Context System"}),"\n",(0,s.jsx)(n.h3,{id:"ferpperceptioncontext",children:"FERPPerceptionContext"}),"\n",(0,s.jsx)(n.p,{children:"The context is an immutable snapshot of perception data, built once per tick and shared across all channels."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provide consistent data to all pipeline stages"}),"\n",(0,s.jsx)(n.li,{children:"Avoid repeated queries (GetActorLocation, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Decouple from specific owner types"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Contents:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct FERPPerceptionContext\r\n{\r\n    AActor* ContextActor;        // Owner (player)\r\n    FVector Origin;              // Player position\r\n    FVector Forward;             // Facing direction\r\n    \r\n    // Optional aim ray\r\n    bool bHasAimRay;\r\n    FVector AimOrigin;\r\n    FVector AimDirection;\r\n    \r\n    // Optional viewport projection\r\n    bool bHasViewportProjection;\r\n    FVector2D ViewportCenterPx;\r\n    float ViewportEllipseHalfWidthPx;\r\n    float ViewportEllipseHalfHeightPx;\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"context-building",children:"Context Building"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Get Owner Actor (component's owner)"}),"\n",(0,s.jsx)(n.li,{children:"Get View Point (location and rotation)"}),"\n",(0,s.jsx)(n.li,{children:"Extract Aim Ray (optional camera aim)"}),"\n",(0,s.jsx)(n.li,{children:"Calculate Viewport Data (for PlayerController)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-immutable",children:"Why Immutable?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Predictable behavior across stages"}),"\n",(0,s.jsx)(n.li,{children:"No hidden state changes"}),"\n",(0,s.jsx)(n.li,{children:"Easy to debug and test"}),"\n",(0,s.jsx)(n.li,{children:"Thread-safe (future)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Implications:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pipeline stages cannot modify context"}),"\n",(0,s.jsx)(n.li,{children:"All stages see identical data"}),"\n",(0,s.jsx)(n.li,{children:"Context rebuilt each tick"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"multi-channel-support",children:"Multi-Channel Support"}),"\n",(0,s.jsx)(n.h3,{id:"channel-independence",children:"Channel Independence"}),"\n",(0,s.jsx)(n.p,{children:"Each channel runs its own complete pipeline:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Own sampler, filters, scorers, aggregator, resolver"}),"\n",(0,s.jsx)(n.li,{children:"Own best candidate"}),"\n",(0,s.jsx)(n.li,{children:"Own events"}),"\n",(0,s.jsx)(n.li,{children:"Independent configuration"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Target Channel:\r\n  - Range: 3000\r\n  - Filters: TargetableFilter\r\n  - Scorers: DistanceScorer, ConeScorer\r\n  \r\nInteraction Channel:\r\n  - Range: 300\r\n  - Filters: InteractableFilter\r\n  - Scorers: DistanceScorer\n"})}),"\n",(0,s.jsx)(n.h3,{id:"shared-context",children:"Shared Context"}),"\n",(0,s.jsx)(n.p,{children:"While channels are independent, they share the same context:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Same origin point"}),"\n",(0,s.jsx)(n.li,{children:"Same forward direction"}),"\n",(0,s.jsx)(n.li,{children:"Same viewport data"}),"\n",(0,s.jsx)(n.li,{children:"Built once, used by all"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"adding-custom-channels",children:"Adding Custom Channels"}),"\n",(0,s.jsx)(n.p,{children:"You can add channels beyond Target and Interaction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Perception|Pipelines")\r\nFERPChannelPipeline CustomPipeline;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Typical setups use 2-3 channels for performance."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,s.jsx)(n.h3,{id:"per-tick-cost",children:"Per Tick Cost"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1x Context build (cheap)"}),"\n",(0,s.jsx)(n.li,{children:"N x Pipeline executions (one per channel)"}),"\n",(0,s.jsx)(n.li,{children:"M x Candidate evaluations (depends on sampler)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"optimization-tips",children:"Optimization Tips"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reduce Sampling Range:"})," Keep ",(0,s.jsx)(n.code,{children:"DefaultSamplingRange"})," reasonable\r\n",(0,s.jsx)(n.strong,{children:"Use Filters Early:"})," Reject candidates before expensive scoring\r\n",(0,s.jsx)(n.strong,{children:"Lightweight Scorers:"})," Keep scoring logic simple\r\n",(0,s.jsx)(n.strong,{children:"Adjust Tick Rate:"})," Use ",(0,s.jsx)(n.code,{children:"PrimaryComponentTick.TickInterval"})," if real-time not needed"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["Learn how to create custom components in ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/Customization",children:"Customization"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Implement interactions in ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/InteractionGuide",children:"Interaction Guide"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Check complete API in ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/API-Reference",children:"API Reference"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453(e,n,i){i.d(n,{R:()=>t,x:()=>c});var r=i(6540);const s={},l=r.createContext(s);function t(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);