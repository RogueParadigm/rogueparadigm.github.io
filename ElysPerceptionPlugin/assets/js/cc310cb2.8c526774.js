"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[990],{304(e,r,n){n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"Targeting","title":"Targeting Guide","description":"This guide covers implementing combat targeting and target lock systems using ElysPerceptionPlugin.","source":"@site/../Documentation/Targeting.md","sourceDirName":".","slug":"/Targeting","permalink":"/ElysPerceptionPlugin/Targeting","draft":false,"unlisted":false,"editUrl":"https://github.com/RogueParadigm/ElysPerceptionPlugin/tree/main/Documentation/../Documentation/Targeting.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Advanced Interaction Guide","permalink":"/ElysPerceptionPlugin/Interaction"},"next":{"title":"Visual Components & Helpers","permalink":"/ElysPerceptionPlugin/HelperComponents"}}');var i=n(4848),a=n(8453);const o={},l="Targeting Guide",c={},s=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"What is the Targeting System?",id:"what-is-the-targeting-system",level:3},{value:"How It Works",id:"how-it-works",level:3},{value:"Basic Setup",id:"basic-setup",level:2},{value:"Step 1: Create the Targeting Channel",id:"step-1-create-the-targeting-channel",level:3},{value:"Step 2: Create Variables",id:"step-2-create-variables",level:3},{value:"Step 3: Bind Events",id:"step-3-bind-events",level:3},{value:"Target Locking",id:"target-locking",level:2},{value:"Basic Lock-On System",id:"basic-lock-on-system",level:3},{value:"Maintaining the Lock",id:"maintaining-the-lock",level:3},{value:"C++ Implementation",id:"c-implementation",level:3},{value:"Target Switching",id:"target-switching",level:2},{value:"Directional Switching",id:"directional-switching",level:3},{value:"C++ Target Switching",id:"c-target-switching",level:3},{value:"Multi-Factor Scoring",id:"multi-factor-scoring",level:2},{value:"Threat-Based Scoring",id:"threat-based-scoring",level:3},{value:"Weighted Aggregator Setup",id:"weighted-aggregator-setup",level:3},{value:"Example: Boss Priority",id:"example-boss-priority",level:3},{value:"Camera Integration",id:"camera-integration",level:2},{value:"Basic Camera Follow",id:"basic-camera-follow",level:3},{value:"Spring Arm Integration",id:"spring-arm-integration",level:3},{value:"Visual Indicators",id:"visual-indicators",level:2},{value:"Lock-On Reticle",id:"lock-on-reticle",level:3},{value:"Soft Target Indicator",id:"soft-target-indicator",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance",id:"performance",level:3},{value:"UX",id:"ux",level:3},{value:"Multiplayer",id:"multiplayer",level:3}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"targeting-guide",children:"Targeting Guide"})}),"\n",(0,i.jsx)(r.p,{children:"This guide covers implementing combat targeting and target lock systems using ElysPerceptionPlugin."}),"\n",(0,i.jsx)(r.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#overview",children:"Overview"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#basic-setup",children:"Basic Setup"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#target-locking",children:"Target Locking"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#target-switching",children:"Target Switching"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#multi-factor-scoring",children:"Multi-Factor Scoring"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#camera-integration",children:"Camera Integration"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#visual-indicators",children:"Visual Indicators"})}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(r.h3,{id:"what-is-the-targeting-system",children:"What is the Targeting System?"}),"\n",(0,i.jsx)(r.p,{children:"The targeting system allows your player to detect and lock onto enemies for combat:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Lock-on targeting"})," (Dark Souls style) - Lock camera to target"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Soft targeting"})," (auto-aim assistance) - Subtle aim adjustment"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Priority targeting"})," (threat-based) - Auto-select most dangerous enemy"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Multi-target management"})," - Track multiple threats"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,i.jsx)(r.p,{children:"The targeting system uses the same pipeline as interaction, but with different configuration:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"[Perception Component] \u2192 Sampler \u2192 Filter \u2192 Scorer \u2192 Aggregator \u2192 Resolver \u2192 [Locked Target]\r\n     (enemies)           (sphere)  (hostile)  (threat) (weighted)  (highest)\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Key differences from interaction:"})}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Aspect"}),(0,i.jsx)(r.th,{children:"Interaction"}),(0,i.jsx)(r.th,{children:"Targeting"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Range"}),(0,i.jsx)(r.td,{children:"200-500 units"}),(0,i.jsx)(r.td,{children:"2000-5000 units"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Scoring"}),(0,i.jsx)(r.td,{children:"Distance only"}),(0,i.jsx)(r.td,{children:"Distance + Angle + Threat"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Lock behavior"}),(0,i.jsx)(r.td,{children:"No lock"}),(0,i.jsx)(r.td,{children:"Persistent lock"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Camera"}),(0,i.jsx)(r.td,{children:"No camera change"}),(0,i.jsx)(r.td,{children:"Camera follows target"})]})]})]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,i.jsx)(r.h3,{id:"step-1-create-the-targeting-channel",children:"Step 1: Create the Targeting Channel"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:'// In your PlayerCharacter Blueprint\r\n\r\nComponents:\r\n- ERP Perception Component (from Interaction setup)\r\n\r\nBegin Play:\r\n  \u2192 ERP Perception Component \u2192 Add Channel\r\n    - Channel ID: "Targeting"  \r\n    - Samplers: [Sphere Sampler (Radius: 3000)]\r\n    - Filters: [Tag Filter ("Enemy"), Line of Sight Filter]\r\n    - Scorers: [Cone Scorer (ConeAngle: 60), Distance Scorer]\r\n    - Aggregator: Weighted Aggregator\r\n    - Resolver: Lowest Score Resolver\n'})}),"\n",(0,i.jsx)(r.h3,{id:"step-2-create-variables",children:"Step 2: Create Variables"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:'Variables:\r\n- IsTargetLocked: Boolean (default: false)\r\n- LockedTarget: Actor Reference (default: None)\r\n- TargetingChannel: Name = "Targeting"\n'})}),"\n",(0,i.jsx)(r.h3,{id:"step-3-bind-events",children:"Step 3: Bind Events"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:'Begin Play:\r\n  \u2192 ERP Perception Component \u2192 Bind to OnChannelCandidateAcquired\r\n    \u2192 Event: Set "SoftTarget" variable\r\n  \u2192 ERP Perception Component \u2192 Bind to OnChannelCandidateLost\r\n    \u2192 Event: Clear "SoftTarget" if matches lost actor\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"target-locking",children:"Target Locking"}),"\n",(0,i.jsx)(r.h3,{id:"basic-lock-on-system",children:"Basic Lock-On System"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:'// Input Action: ToggleTargetLock (Gamepad: R3 / Keyboard: Tab)\r\n\r\nEvent ToggleTargetLock:\r\n  \u2192 Branch: IsTargetLocked\r\n  \r\n  [True - Unlock]:\r\n    \u2192 Set IsTargetLocked = false\r\n    \u2192 Set LockedTarget = None\r\n    \u2192 (Optional) Reset Camera\r\n    \u2192 Event "OnTargetUnlocked"\r\n    \r\n  [False - Lock]:\r\n    \u2192 Get Perception Component \u2192 Get Channel Candidate ("Targeting")\r\n    \u2192 Branch: Is Valid?\r\n      [True]:\r\n        \u2192 Set LockedTarget = Candidate\r\n        \u2192 Set IsTargetLocked = true\r\n        \u2192 Event "OnTargetLocked" (pass LockedTarget)\r\n      [False]:\r\n        \u2192 (Optional) Play "No Target" feedback\n'})}),"\n",(0,i.jsx)(r.h3,{id:"maintaining-the-lock",children:"Maintaining the Lock"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:"// In Tick or Timer (every 0.1s)\r\n\r\nBranch: IsTargetLocked AND LockedTarget is Valid\r\n  [True]:\r\n    \u2192 Get Distance to LockedTarget\r\n    \u2192 Branch: Distance > MaxLockDistance (e.g., 4000)\r\n      [True]: \u2192 Call UnlockTarget\r\n      \r\n    \u2192 (Optional) Line Trace to LockedTarget\r\n    \u2192 Branch: Blocked for > 2 seconds?\r\n      [True]: \u2192 Call UnlockTarget\r\n      \r\n  [False]:\r\n    \u2192 If IsTargetLocked but LockedTarget invalid:\r\n      \u2192 Call UnlockTarget\n"})}),"\n",(0,i.jsx)(r.h3,{id:"c-implementation",children:"C++ Implementation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// TargetingComponent.h\r\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\r\nclass UERPTargetingComponent : public UActorComponent\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    UPROPERTY(BlueprintReadOnly, Category = "Targeting")\r\n    bool bIsTargetLocked = false;\r\n    \r\n    UPROPERTY(BlueprintReadOnly, Category = "Targeting")\r\n    TWeakObjectPtr<AActor> LockedTarget;\r\n    \r\n    UPROPERTY(EditDefaultsOnly, Category = "Targeting")\r\n    float MaxLockDistance = 4000.0f;\r\n    \r\n    UPROPERTY(EditDefaultsOnly, Category = "Targeting")\r\n    float LockBreakTime = 2.0f;\r\n    \r\n    UFUNCTION(BlueprintCallable, Category = "Targeting")\r\n    bool TryLockTarget();\r\n    \r\n    UFUNCTION(BlueprintCallable, Category = "Targeting")\r\n    void UnlockTarget();\r\n    \r\n    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTargetLocked, AActor*, Target);\r\n    UPROPERTY(BlueprintAssignable)\r\n    FOnTargetLocked OnTargetLocked;\r\n    \r\n    DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnTargetUnlocked);\r\n    UPROPERTY(BlueprintAssignable)\r\n    FOnTargetUnlocked OnTargetUnlocked;\r\n\r\nprotected:\r\n    UPROPERTY()\r\n    UERPPerceptionComponent* PerceptionComponent;\r\n    \r\n    FName TargetingChannelId = "Targeting";\r\n    float TimeTargetObstructed = 0.0f;\r\n};\r\n\r\n// TargetingComponent.cpp\r\nbool UERPTargetingComponent::TryLockTarget()\r\n{\r\n    if (!PerceptionComponent) return false;\r\n    \r\n    if (AActor* Candidate = PerceptionComponent->GetChannelCandidate(TargetingChannelId))\r\n    {\r\n        LockedTarget = Candidate;\r\n        bIsTargetLocked = true;\r\n        TimeTargetObstructed = 0.0f;\r\n        OnTargetLocked.Broadcast(Candidate);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid UERPTargetingComponent::UnlockTarget()\r\n{\r\n    AActor* PreviousTarget = LockedTarget.Get();\r\n    LockedTarget.Reset();\r\n    bIsTargetLocked = false;\r\n    TimeTargetObstructed = 0.0f;\r\n    OnTargetUnlocked.Broadcast();\r\n}\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"target-switching",children:"Target Switching"}),"\n",(0,i.jsx)(r.h3,{id:"directional-switching",children:"Directional Switching"}),"\n",(0,i.jsx)(r.p,{children:"Switch to the next target in a direction (left/right based on stick input):"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:"// Input: Right Stick X-Axis\r\n\r\nEvent SwitchTargetDirection (Axis Value):\r\n  \u2192 Branch: IsTargetLocked AND Abs(AxisValue) > 0.5\r\n  \r\n  [True]:\r\n    \u2192 Get All Actors in Targeting Channel (from Perception)\r\n    \u2192 Filter: Remove current LockedTarget\r\n    \u2192 Filter: Remove actors not in direction\r\n    \r\n    // Get direction from camera\r\n    \u2192 Get Camera Right Vector\r\n    \u2192 For Each Actor:\r\n      \u2192 Dot Product: (ActorLocation - PlayerLocation).Normalized \u2022 CameraRight\r\n      \u2192 If AxisValue > 0: Keep actors where Dot > 0.3\r\n      \u2192 If AxisValue < 0: Keep actors where Dot < -0.3\r\n    \r\n    \u2192 Sort remaining by angle from center\r\n    \u2192 Set LockedTarget = First actor (closest to center in that direction)\n"})}),"\n",(0,i.jsx)(r.h3,{id:"c-target-switching",children:"C++ Target Switching"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"void UERPTargetingComponent::SwitchTarget(float Direction)\r\n{\r\n    if (!bIsTargetLocked || !PerceptionComponent) return;\r\n    \r\n    AActor* Owner = GetOwner();\r\n    if (!Owner) return;\r\n    \r\n    // Get camera right vector for directional reference\r\n    APlayerController* PC = Cast<APlayerController>(Owner->GetInstigatorController());\r\n    if (!PC) return;\r\n    \r\n    FVector CameraRight = PC->PlayerCameraManager->GetCameraRotation().RotateVector(FVector::RightVector);\r\n    FVector PlayerLocation = Owner->GetActorLocation();\r\n    \r\n    AActor* BestCandidate = nullptr;\r\n    float BestScore = TNumericLimits<float>::Max();\r\n    \r\n    // Get all current candidates from perception\r\n    TArray<FERPPipelineCandidate> Candidates;\r\n    // Note: You'd need to expose GetAllCandidates or iterate registered actors\r\n    \r\n    for (const auto& Candidate : Candidates)\r\n    {\r\n        if (Candidate.Actor == LockedTarget.Get()) continue;\r\n        \r\n        FVector ToTarget = (Candidate.Actor->GetActorLocation() - PlayerLocation).GetSafeNormal();\r\n        float DotRight = FVector::DotProduct(ToTarget, CameraRight);\r\n        \r\n        // Check if target is in the requested direction\r\n        if ((Direction > 0 && DotRight > 0.2f) || (Direction < 0 && DotRight < -0.2f))\r\n        {\r\n            float Score = FMath::Abs(DotRight); // Prefer targets more to the side\r\n            if (Score < BestScore)\r\n            {\r\n                BestScore = Score;\r\n                BestCandidate = Candidate.Actor;\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (BestCandidate)\r\n    {\r\n        LockedTarget = BestCandidate;\r\n        OnTargetLocked.Broadcast(BestCandidate);\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"multi-factor-scoring",children:"Multi-Factor Scoring"}),"\n",(0,i.jsx)(r.h3,{id:"threat-based-scoring",children:"Threat-Based Scoring"}),"\n",(0,i.jsx)(r.p,{children:"Create a custom scorer that factors in threat level:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// ERPThreatScorer.h\r\nUCLASS(Blueprintable, EditInlineNew, DefaultToInstanced)\r\nclass UERPThreatScorer : public UERPBaseScorer\r\n{\r\n    GENERATED_BODY()\r\n\r\npublic:\r\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Scoring")\r\n    float ThreatWeight = 1.0f;\r\n    \r\nprotected:\r\n    virtual float Score_Implementation(const FERPPipelineContext& Context, AActor* Candidate) override\r\n    {\r\n        // Check for threat interface\r\n        if (IERPThreatSource* ThreatSource = Cast<IERPThreatSource>(Candidate))\r\n        {\r\n            float ThreatLevel = ThreatSource->GetThreatLevel(); // 0.0 - 1.0\r\n            // Invert so higher threat = lower score (better)\r\n            return (1.0f - ThreatLevel) * ThreatWeight;\r\n        }\r\n        return 0.5f * ThreatWeight; // Neutral threat if no interface\r\n    }\r\n};\n'})}),"\n",(0,i.jsx)(r.h3,{id:"weighted-aggregator-setup",children:"Weighted Aggregator Setup"}),"\n",(0,i.jsx)(r.p,{children:"Combine multiple scores with weights:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:"// Pipeline Configuration\r\n\r\nScorers:\r\n  1. Distance Scorer (Weight: 0.4)\r\n     - Closer = better\r\n  \r\n  2. Cone Scorer (Weight: 0.3)  \r\n     - More centered in view = better\r\n  \r\n  3. Threat Scorer (Weight: 0.3)\r\n     - Higher threat level = better (prioritize dangerous enemies)\r\n\r\nAggregator: Weighted Aggregator\r\n  - Automatically uses scorer weights\r\n  - Final Score = \u03a3(ScoreN \xd7 WeightN) / \u03a3(WeightN)\n"})}),"\n",(0,i.jsx)(r.h3,{id:"example-boss-priority",children:"Example: Boss Priority"}),"\n",(0,i.jsx)(r.p,{children:"Make bosses always highest priority:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'float UERPThreatScorer::Score_Implementation(const FERPPipelineContext& Context, AActor* Candidate)\r\n{\r\n    // Bosses always get priority (lowest score)\r\n    if (Candidate->ActorHasTag("Boss"))\r\n    {\r\n        return -1000.0f; // Guaranteed to win\r\n    }\r\n    \r\n    // Elite enemies get high priority\r\n    if (Candidate->ActorHasTag("Elite"))\r\n    {\r\n        return 0.1f;\r\n    }\r\n    \r\n    // Regular enemies based on interface\r\n    if (IERPThreatSource* ThreatSource = Cast<IERPThreatSource>(Candidate))\r\n    {\r\n        return 1.0f - ThreatSource->GetThreatLevel();\r\n    }\r\n    \r\n    return 0.5f;\r\n}\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"camera-integration",children:"Camera Integration"}),"\n",(0,i.jsx)(r.h3,{id:"basic-camera-follow",children:"Basic Camera Follow"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:"// In PlayerController or CameraManager Tick\r\n\r\nBranch: IsTargetLocked AND LockedTarget is Valid\r\n\r\n[True]:\r\n  \u2192 Find Look at Rotation (from Camera to LockedTarget)\r\n  \u2192 Interp Rotation (Current \u2192 LookAt, DeltaTime, 5.0)\r\n  \u2192 Set Control Rotation\r\n  \r\n  // Optional: Offset so target is slightly off-center\r\n  \u2192 Add Rotation Offset (Yaw: -10 degrees)\n"})}),"\n",(0,i.jsx)(r.h3,{id:"spring-arm-integration",children:"Spring Arm Integration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:"// Camera Setup for Lock-On\r\n\r\nVariables:\r\n- DefaultArmLength: 400\r\n- LockedArmLength: 500\r\n- DefaultSocketOffset: (0, 0, 50)\r\n- LockedSocketOffset: (0, 50, 80)  // Offset to see target better\r\n\r\nEvent OnTargetLocked:\r\n  \u2192 Timeline: Blend (0\u21921 over 0.3s)\r\n    \u2192 Lerp Spring Arm Length (Default \u2192 Locked)\r\n    \u2192 Lerp Socket Offset (Default \u2192 Locked)\r\n    \r\nEvent OnTargetUnlocked:\r\n  \u2192 Timeline: Blend (1\u21920 over 0.3s)\r\n    \u2192 Lerp back to defaults\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"visual-indicators",children:"Visual Indicators"}),"\n",(0,i.jsx)(r.h3,{id:"lock-on-reticle",children:"Lock-On Reticle"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:"// Widget: WBP_TargetReticle\r\n\r\nComponents:\r\n- Image (Reticle texture, anchored center)\r\n- Optional: Health bar, enemy name\r\n\r\n// In PlayerController or HUD\r\n\r\nEvent OnTargetLocked (Target):\r\n  \u2192 Create Widget: WBP_TargetReticle\r\n  \u2192 Add to Viewport\r\n  \u2192 Store reference\r\n  \r\nEvent OnTargetUnlocked:\r\n  \u2192 Remove Widget from Parent\r\n\r\nTick (while locked):\r\n  \u2192 Project World to Screen (LockedTarget location + offset)\r\n  \u2192 Set Widget Position\r\n  \u2192 (Optional) Scale based on distance\n"})}),"\n",(0,i.jsx)(r.h3,{id:"soft-target-indicator",children:"Soft Target Indicator"}),"\n",(0,i.jsx)(r.p,{children:"Show which target would be selected if player locks:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-blueprint",children:'// Lighter indicator for "soft" target (not locked yet)\r\n\r\nEvent OnChannelCandidateAcquired ("Targeting", Actor):\r\n  \u2192 Branch: NOT IsTargetLocked\r\n    \u2192 Show soft target indicator on Actor\r\n    \r\nEvent OnChannelCandidateLost ("Targeting", Actor):\r\n  \u2192 Hide soft target indicator\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(r.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Use appropriate update rates (0.1s for targeting checks, not every frame)"}),"\n",(0,i.jsx)(r.li,{children:"Cache perception results, don't query every frame"}),"\n",(0,i.jsx)(r.li,{children:"Limit sampler range to what's actually needed"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"ux",children:"UX"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Provide clear visual feedback for lock state"}),"\n",(0,i.jsx)(r.li,{children:"Allow easy unlock (same button, or movement-based)"}),"\n",(0,i.jsx)(r.li,{children:'Consider "sticky" targeting that doesn\'t break easily'}),"\n",(0,i.jsx)(r.li,{children:"Audio feedback for lock/unlock"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"multiplayer",children:"Multiplayer"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Target locking is client-side only"}),"\n",(0,i.jsx)(r.li,{children:"Don't replicate lock state"}),"\n",(0,i.jsx)(r.li,{children:"Server validates attacks independently"}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Previous:"})," ",(0,i.jsx)(r.a,{href:"/ElysPerceptionPlugin/Interaction",children:"Interaction Guide"})," | ",(0,i.jsx)(r.strong,{children:"Next:"})," ",(0,i.jsx)(r.a,{href:"/ElysPerceptionPlugin/HelperComponents",children:"Helper Components"})," | ",(0,i.jsx)(r.a,{href:"/ElysPerceptionPlugin/intro",children:"Documentation Home"})]})]})}function g(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,r,n){n.d(r,{R:()=>o,x:()=>l});var t=n(6540);const i={},a=t.createContext(i);function o(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);