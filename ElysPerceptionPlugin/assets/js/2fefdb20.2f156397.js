"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[698],{7498(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"PipelineGuide","title":"Pipeline Guide","description":"This guide explains how the ElysPerceptionPlugin\'s sampling pipeline works under the hood.","source":"@site/../Documentation/PipelineGuide.md","sourceDirName":".","slug":"/PipelineGuide","permalink":"/ElysPerceptionPlugin/PipelineGuide","draft":false,"unlisted":false,"editUrl":"https://github.com/RogueParadigm/ElysPerceptionPlugin/tree/main/Documentation/../Documentation/PipelineGuide.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"PipelineGuide","title":"Pipeline Guide","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Visual Components & Helpers","permalink":"/ElysPerceptionPlugin/HelperComponents"},"next":{"title":"System Overview","permalink":"/ElysPerceptionPlugin/ArchitectureDeepDive"}}');var s=r(4848),l=r(8453);const t={id:"PipelineGuide",title:"Pipeline Guide",sidebar_position:3},c="Pipeline Guide",o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"What is the Pipeline?",id:"what-is-the-pipeline",level:3},{value:"Why Use a Pipeline?",id:"why-use-a-pipeline",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"The Big Picture",id:"the-big-picture",level:3},{value:"A Simple Example",id:"a-simple-example",level:3},{value:"Pipeline Stages",id:"pipeline-stages",level:2},{value:"Stage 1: Sampler",id:"stage-1-sampler",level:3},{value:"Stage 2: Filters",id:"stage-2-filters",level:3},{value:"Stage 3: Scorers",id:"stage-3-scorers",level:3},{value:"Stage 4: Aggregator",id:"stage-4-aggregator",level:3},{value:"Stage 5: Resolver",id:"stage-5-resolver",level:3},{value:"Context System",id:"context-system",level:2},{value:"What is Context?",id:"what-is-context",level:3},{value:"Context Contents",id:"context-contents",level:3},{value:"How Context is Built",id:"how-context-is-built",level:3},{value:"Using Context in Pipeline Stages",id:"using-context-in-pipeline-stages",level:3},{value:"Multi-Channel Support",id:"multi-channel-support",level:2},{value:"What are Channels?",id:"what-are-channels",level:3},{value:"How Channels Work",id:"how-channels-work",level:3},{value:"Focus System",id:"focus-system",level:3},{value:"Channel Configuration",id:"channel-configuration",level:3},{value:"Execution Flow",id:"execution-flow",level:2},{value:"Complete Tick Flow",id:"complete-tick-flow",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pipeline-guide",children:"Pipeline Guide"})}),"\n",(0,s.jsx)(n.p,{children:"This guide explains how the ElysPerceptionPlugin's sampling pipeline works under the hood."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#how-it-works",children:"How It Works"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#pipeline-stages",children:"Pipeline Stages"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#context-system",children:"Context System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#multi-channel-support",children:"Multi-Channel Support"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#execution-flow",children:"Execution Flow"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-the-pipeline",children:"What is the Pipeline?"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Pipeline"})," is the core detection and evaluation system that finds and ranks potential targets or interactables in your game world."]}),"\n",(0,s.jsx)(n.p,{children:"Think of it like a factory assembly line:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gather"})," potential objects (Sampler)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remove"})," invalid ones (Filters)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate"})," the remaining ones (Scorers)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Combine"})," ratings (Aggregator)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pick"})," the best one (Resolver)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-use-a-pipeline",children:"Why Use a Pipeline?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modular"}),": Each stage does one job"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configurable"}),": Mix and match components without code"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extensible"}),": Add custom logic easily"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reusable"}),": Same components work for different use cases"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainable"}),": Debug one stage at a time"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Comparison to traditional systems:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Traditional"}),(0,s.jsx)(n.th,{children:"Pipeline"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hardcoded logic"}),(0,s.jsx)(n.td,{children:"Configurable components"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"One-size-fits-all"}),(0,s.jsx)(n.td,{children:"Mix and match"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hard to customize"}),(0,s.jsx)(n.td,{children:"Easy to extend"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Tightly coupled"}),(0,s.jsx)(n.td,{children:"Loosely coupled"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsx)(n.h3,{id:"the-big-picture",children:"The Big Picture"}),"\n",(0,s.jsxs)(n.p,{children:["Every tick, the ",(0,s.jsx)(n.code,{children:"ERPPerceptionComponent"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Builds Context"})," - Snapshot of player position, view direction, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runs Each Channel"})," - Target, Interaction, Custom channels run independently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fires Events"})," - Notifies your game of channel-specific changes (OnChannelCandidateAcquired/Lost)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"a-simple-example",children:"A Simple Example"}),"\n",(0,s.jsx)(n.p,{children:"Let's trace through a target detection:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Setup:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Player at position (0, 0, 0)"}),"\n",(0,s.jsx)(n.li,{children:"Enemy A at (500, 0, 0) - 500 units away"}),"\n",(0,s.jsx)(n.li,{children:"Enemy B at (1000, 0, 0) - 1000 units away"}),"\n",(0,s.jsxs)(n.li,{children:["Both enemies implement ",(0,s.jsx)(n.code,{children:"IERPTargetable"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pipeline Execution:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sampler"})," runs:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sphere overlap finds both Enemy A and Enemy B"}),"\n",(0,s.jsxs)(n.li,{children:["Result: ",(0,s.jsx)(n.code,{children:"[Enemy A, Enemy B]"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Filters"})," run:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPTargetableFilter"})," checks if each enemy can be targeted"]}),"\n",(0,s.jsxs)(n.li,{children:["Enemy A: ",(0,s.jsx)(n.code,{children:"CanBeTargetedBy()"})," \u2192 ",(0,s.jsx)(n.code,{children:"true"})," \u2713"]}),"\n",(0,s.jsxs)(n.li,{children:["Enemy B: ",(0,s.jsx)(n.code,{children:"CanBeTargetedBy()"})," \u2192 ",(0,s.jsx)(n.code,{children:"true"})," \u2713"]}),"\n",(0,s.jsxs)(n.li,{children:["Result: ",(0,s.jsx)(n.code,{children:"[Enemy A, Enemy B]"})," (both pass)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scorers"})," run:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPDistanceScorer"})," calculates distance for each"]}),"\n",(0,s.jsx)(n.li,{children:"Enemy A: 500 units \u2192 score 0.25 (normalized)"}),"\n",(0,s.jsx)(n.li,{children:"Enemy B: 1000 units \u2192 score 0.5 (normalized)"}),"\n",(0,s.jsxs)(n.li,{children:["Result: ",(0,s.jsx)(n.code,{children:"[(Enemy A, 0.25), (Enemy B, 0.5)]"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Aggregator"})," runs:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPIdentityAggregator"})," passes through scores (only one scorer)"]}),"\n",(0,s.jsxs)(n.li,{children:["Result: ",(0,s.jsx)(n.code,{children:"[(Enemy A, 0.25), (Enemy B, 0.5)]"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Resolver"})," runs:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPLowestScoreResolver"})," picks the lowest score"]}),"\n",(0,s.jsxs)(n.li,{children:["Result: ",(0,s.jsx)(n.strong,{children:"Enemy A is best"})," (0.25 < 0.5)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Events fire"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'OnChannelCandidateAcquired("Target", Enemy A)'})," fires"]}),"\n",(0,s.jsx)(n.li,{children:"Your UI shows target indicator on Enemy A"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-stages",children:"Pipeline Stages"}),"\n",(0,s.jsx)(n.h3,{id:"stage-1-sampler",children:"Stage 1: Sampler"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Job"}),": Collect potential candidates from the world"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How"}),": Performs a spatial query (overlap, raycast, etc.)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Array of actors ",(0,s.jsx)(n.code,{children:"[Actor1, Actor2, ...]"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPSphereOverlapSampler"})," - Sphere overlap around player"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Sampler: ERPSphereOverlapSampler\r\n  - Trace Channel: Pawn\r\n  - Actor Class: Character\r\n  - Ignore Context Actor: \u2713\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What it does:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Performs ",(0,s.jsx)(n.code,{children:"SphereOverlapActors"})," at player position"]}),"\n",(0,s.jsx)(n.li,{children:"Uses configured trace channel for filtering"}),"\n",(0,s.jsx)(n.li,{children:"Optionally filters by actor class"}),"\n",(0,s.jsx)(n.li,{children:"Can ignore the player actor itself"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-2-filters",children:"Stage 2: Filters"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Job"}),": Remove invalid candidates (binary pass/fail)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How"}),": Each filter checks one condition; ALL must pass"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Filtered array of actors"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPTargetableFilter"})," - Requires ",(0,s.jsx)(n.code,{children:"IERPTargetable"})," interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPInteractableFilter"})," - Requires ",(0,s.jsx)(n.code,{children:"IERPInteractable"})," interface"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Filters:\r\n  - ERPTargetableFilter\r\n  - [Your custom filter]\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution:"}),"\r\nFilters run in sequence with ",(0,s.jsx)(n.strong,{children:"short-circuit evaluation"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If Filter 1 fails \u2192 actor rejected immediately"}),"\n",(0,s.jsx)(n.li,{children:"If Filter 1 passes \u2192 Filter 2 runs"}),"\n",(0,s.jsx)(n.li,{children:"And so on..."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Filter Logic:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool Passes(Context, Candidate)\r\n{\r\n    // Check if actor implements interface\r\n    if (!Candidate->Implements<UERPTargetable>())\r\n        return false;\r\n    \r\n    // Ask the actor if it can be targeted\r\n    return IERPTargetable::Execute_CanBeTargetedBy(Candidate, Context.ContextActor);\r\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-3-scorers",children:"Stage 3: Scorers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Job"}),": Assign numerical scores to candidates"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How"}),": Each scorer evaluates one aspect; produces one number per candidate"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Array of scores per candidate ",(0,s.jsx)(n.code,{children:"[[0.5, 0.3], [0.8, 0.2]]"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPDistanceScorer"})," - Score by distance (lower = closer)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPConeScorer"})," - Score by angle from view direction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPViewportEllipseScorer"})," - Score by screen position"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Scorers:\r\n  - ERPDistanceScorer (Normalize By Range: \u2713)\r\n  - ERPConeScorer\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What they do:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Distance Scorer"}),": Closer objects score lower (better)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cone Scorer"}),": Objects in center of view score lower"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Viewport Scorer"}),": Objects near screen center score lower"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Score Ranges:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Typically normalized to 0.0 - 1.0"}),"\n",(0,s.jsx)(n.li,{children:"Lower scores = better (by convention)"}),"\n",(0,s.jsx)(n.li,{children:"Can be any range, but normalize for easier combination"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-4-aggregator",children:"Stage 4: Aggregator"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Job"}),": Combine multiple scores into one final score"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How"}),": Takes array of scores, returns single number"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": One score per candidate"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPIdentityAggregator"})," - Pass through first score (for single scorer)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPAdditiveAggregator"})," - Sum all scores"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPMultiplicativeAggregator"})," - Multiply all scores"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Aggregator: ERPIdentityAggregator  // For 1 scorer\r\nor\r\nAggregator: ERPAdditiveAggregator  // For multiple scorers\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Candidate A scores: [0.3 (distance), 0.2 (angle)]\r\nCandidate B scores: [0.5 (distance), 0.1 (angle)]\r\n\r\nAdditive Aggregator:\r\n  A: 0.3 + 0.2 = 0.5\r\n  B: 0.5 + 0.1 = 0.6\r\n  \u2192 A wins (lower score)\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"stage-5-resolver",children:"Stage 5: Resolver"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Job"}),": Select the winning candidate"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How"}),": Examines all final scores and picks the best"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Single best candidate (or none)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default Implementations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPLowestScoreResolver"})," - Lowest score wins"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ERPHighestScoreResolver"})," - Highest score wins"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Resolver: ERPLowestScoreResolver  // For distance-based (closer = better)\r\nor\r\nResolver: ERPHighestScoreResolver  // For priority-based (higher = better)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What it does:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Iterates through all scored candidates"}),"\n",(0,s.jsx)(n.li,{children:"Finds minimum (or maximum) score"}),"\n",(0,s.jsx)(n.li,{children:"Returns that candidate as the winner"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"context-system",children:"Context System"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-context",children:"What is Context?"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Context"})," is a snapshot of the player's state at the moment of evaluation. It's built once per tick and shared across all pipeline stages."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistency"}),": All stages see the same data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Avoid repeated queries (GetActorLocation, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": Works with different owner types (Controller, Pawn, etc.)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"context-contents",children:"Context Contents"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct FERPPerceptionContext\r\n{\r\n    // Core data (always present)\r\n    AActor* ContextActor;           // The owner (player)\r\n    FVector Origin;                 // Player position\r\n    FVector Forward;                // Player facing direction\r\n    \r\n    // Optional aim ray (for camera/weapon aiming)\r\n    bool bHasAimRay;\r\n    FVector AimOrigin;\r\n    FVector AimDirection;\r\n    \r\n    // Optional viewport data (for screen-space scoring)\r\n    bool bHasViewportProjection;\r\n    FVector2D ViewportCenterPx;\r\n    float ViewportEllipseHalfWidthPx;\r\n    float ViewportEllipseHalfHeightPx;\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-context-is-built",children:"How Context is Built"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Get Owner"}),": Component owner (PlayerController or Pawn)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Get View Point"}),": Position and rotation for perception"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extract Aim Ray"}),": Camera or weapon aim (if available)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Calculate Viewport"}),": Screen-space data (for PlayerController only)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"using-context-in-pipeline-stages",children:"Using Context in Pipeline Stages"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Distance Scorer Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float Score(const FERPPerceptionContext& Context, AActor* Candidate)\r\n{\r\n    FVector CandidateLocation = Candidate->GetActorLocation();\r\n    float Distance = FVector::Dist(Context.Origin, CandidateLocation);\r\n    return Distance / MaxRange;  // Normalized\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Cone Scorer Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float Score(const FERPPerceptionContext& Context, AActor* Candidate)\r\n{\r\n    FVector ToCandidate = (Candidate->GetActorLocation() - Context.Origin).GetSafeNormal();\r\n    float DotProduct = FVector::DotProduct(Context.Forward, ToCandidate);\r\n    return (1.0f - DotProduct) / 2.0f;  // Convert -1..1 to 0..1\r\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"multi-channel-support",children:"Multi-Channel Support"}),"\n",(0,s.jsx)(n.h3,{id:"what-are-channels",children:"What are Channels?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Channels"})," are independent pipelines that run in parallel. Each channel maintains its own best candidate."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common channels:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Target"}),": Combat targeting (enemies)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interaction"}),": Object interaction (doors, items)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom"}),": Healing, quest objectives, etc."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"how-channels-work",children:"How Channels Work"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Each channel has:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Its own pipeline configuration (Sampler, Filters, Scorers, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Its own best candidate"}),"\n",(0,s.jsx)(n.li,{children:"Its own events"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Channels run:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Independently (Target doesn't affect Interaction)"}),"\n",(0,s.jsx)(n.li,{children:"Simultaneously (all channels evaluated each tick)"}),"\n",(0,s.jsx)(n.li,{children:"With shared context (same snapshot)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"focus-system",children:"Focus System"}),"\n",(0,s.jsxs)(n.p,{children:["When multiple channels have candidates, the system determines ",(0,s.jsx)(n.strong,{children:"focus"}),":"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Focus rules:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only ONE channel can have focus at a time"}),"\n",(0,s.jsx)(n.li,{children:'Focus determines which candidate is "primary"'}),"\n",(0,s.jsx)(n.li,{children:'Non-focus channels still track their best, but are "secondary"'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Target Channel: Enemy A (has focus) \u2192 Primary target, orange outline\r\nInteraction Channel: Door B (no focus) \u2192 Secondary, blue outline\n"})}),"\n",(0,s.jsx)(n.h3,{id:"channel-configuration",children:"Channel Configuration"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example: Two channels"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Target Pipeline:\r\n  Channel Id: Target\r\n  Range: 3000\r\n  Sampler: Sphere (Pawn collision)\r\n  Filters: TargetableFilter\r\n  Scorers: DistanceScorer\r\n  \r\nInteraction Pipeline:\r\n  Channel Id: Interaction\r\n  Range: 300\r\n  Sampler: Sphere (Visibility collision)\r\n  Filters: InteractableFilter\r\n  Scorers: DistanceScorer\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,s.jsx)(n.h3,{id:"complete-tick-flow",children:"Complete Tick Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1. UERPPerceptionComponent::TickComponent()\r\n   \u2193\r\n2. BuildContext()\r\n   \u2192 Get owner actor\r\n   \u2192 Get view point (position, rotation)\r\n   \u2192 Extract aim ray\r\n   \u2192 Calculate viewport data\r\n   \u2192 Create FERPPerceptionContext\r\n   \u2193\r\n3. For each channel:\r\n   \u2193\r\n   3a. Execute Pipeline:\r\n       \u2192 Sampler: Gather candidates\r\n       \u2192 Filters: Reject invalid\r\n       \u2192 Scorers: Assign scores\r\n       \u2192 Aggregator: Combine scores\r\n       \u2192 Resolver: Select best\r\n   \u2193\r\n   3b. Store result (best candidate + score)\r\n   \u2193\r\n4. Determine Focus Winner\r\n   \u2192 Compare channel priorities\r\n   \u2192 Assign focus to one channel\r\n   \u2193\r\n5. Fire Events:\r\n   \u2192 OnCandidateAcquired (for new candidates)\r\n   \u2192 OnCandidateLost (for lost candidates)\r\n   \u2192 OnFocusStatusChanged (for focus changes)\r\n   \u2193\r\n6. Update Debug Visualization (if enabled)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Per Tick:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1x Context build (cheap)"}),"\n",(0,s.jsx)(n.li,{children:"N\xd7 Pipeline executions (one per channel)"}),"\n",(0,s.jsx)(n.li,{children:"M\xd7 Candidate evaluations (depends on sampler results)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization tips:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep sampling range reasonable"}),"\n",(0,s.jsx)(n.li,{children:"Use filters to reject early"}),"\n",(0,s.jsx)(n.li,{children:"Keep scorer logic lightweight"}),"\n",(0,s.jsx)(n.li,{children:"Adjust component tick interval if real-time isn't needed"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you understand how the pipeline works:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/AdvancedCustomization",children:"Advanced Customization"})})," - Create custom pipeline components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/API-Reference",children:"API Reference"})})," - Complete API documentation"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Previous:"})," ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/HelperComponents",children:"Helper Components"})," | ",(0,s.jsx)(n.strong,{children:"Next:"})," ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/ArchitectureDeepDive",children:"Architecture Deep Dive"})," | ",(0,s.jsx)(n.a,{href:"/ElysPerceptionPlugin/intro",children:"Documentation Home"})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453(e,n,r){r.d(n,{R:()=>t,x:()=>c});var i=r(6540);const s={},l=i.createContext(s);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);